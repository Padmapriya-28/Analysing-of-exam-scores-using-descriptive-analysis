import pandas as pd
install.packages(c("ggplot2", "dplyr", "caret", "cluster", "factoextra", "e1071"))
# Load required libraries
library(ggplot2)
library(dplyr)
library(caret)
library(cluster)
library(factoextra)
library(e1071)
# Load dataset
data <- read.csv("C:\Users\padma\Downloads\results.csv")
# Load required libraries
library(ggplot2)
library(dplyr)
library(caret)
library(cluster)
library(factoextra)
library(e1071)
# Load dataset
data <- read.csv("C:\\Users\\padma\\Downloads\\results.csv")
# View structure
str(data)
# Drop unnecessary column
data <- data[ , !(names(data) %in% c("Unnamed..0"))]
# -------------------------------
# 1. Descriptive Analysis
# -------------------------------
summary(data)
# Correlation heatmap
cor_matrix <- cor(data[, c("Hindi", "English", "Science", "Maths", "History", "Geograpgy", "Total")])
print(cor_matrix)
# Histogram of Total Scores
ggplot(data, aes(x = Total)) +
geom_histogram(bins = 30, fill = "skyblue", color = "black") +
ggtitle("Distribution of Total Marks")
# -------------------------------
# 2. K-Means Clustering
# -------------------------------
# Normalize marks
marks <- scale(data[, c("Hindi", "English", "Science", "Maths", "History", "Geograpgy", "Total")])
# Determine optimal k
wss <- sapply(1:10, function(k) kmeans(marks, centers = k, nstart = 10)$tot.withinss)
plot(1:10, wss, type = "b", col = "red", pch = 19, xlab = "Number of Clusters", ylab = "WSS")
# Apply k-means with 3 clusters
set.seed(123)
km <- kmeans(marks, centers = 3, nstart = 25)
data$Cluster <- as.factor(km$cluster)
# Visualize clusters
fviz_cluster(km, data = marks)
# -------------------------------
# 3. Linear Regression
# -------------------------------
reg_model <- lm(Total ~ Hindi + English + Science + Maths + History + Geograpgy, data = data)
summary(reg_model)
# Predict and plot
data$Predicted_Total <- predict(reg_model, data)
ggplot(data, aes(x = Total, y = Predicted_Total)) +
geom_point() +
geom_abline(slope = 1, intercept = 0, col = "blue") +
ggtitle("Actual vs Predicted Total Marks")
# -------------------------------
# 4. Classification (Logistic Regression)
# -------------------------------
data$Results <- as.factor(data$Results)
# Split into training and test sets
set.seed(123)
index <- createDataPartition(data$Results, p = 0.7, list = FALSE)
train <- data[index, ]
test <- data[-index, ]
# Logistic regression model
logit_model <- glm(Results ~ Hindi + English + Science + Maths + History + Geograpgy,
data = train, family = "binomial")
summary(logit_model)
# Predictions on test set
test$Prob <- predict(logit_model, newdata = test, type = "response")
test$Predicted <- ifelse(test$Prob > 0.5, 1, 0)
test$Predicted <- as.factor(test$Predicted)
# Confusion matrix
confusionMatrix(test$Predicted, test$Results)
# Accuracy
accuracy <- mean(test$Predicted == test$Results)
cat("Accuracy:", round(accuracy * 100, 2), "%\n")
clr
clrhash()
clc
cls
cls()
# Load libraries
library(ggplot2)
library(dplyr)
library(caret)
library(cluster)
library(factoextra)
library(e1071)
# Load dataset
data <- read.csv("C:/Users/padma/Downloads/results.csv")
# Descriptive statistics
summary(data)
sapply(data[,2:8], sd)  # standard deviation of scores
# Correlation matrix
cor_matrix <- cor(data[,2:7])
print(cor_matrix)
# K-Means Clustering
scores <- scale(data[,2:7])  # Standardize
kmeans_model <- kmeans(scores, centers = 3)
data$Cluster <- as.factor(kmeans_model$cluster)
# View first few cluster assignments
head(data[, c("Total", "Cluster")])
# Visualize clusters
fviz_cluster(kmeans_model, data = scores)
# Regression model (predicting Total)
reg_model <- lm(Total ~ Hindi + English + Science + Maths + History + Geograpgy, data = data)
summary(reg_model)
# Add predicted total to dataset
data$Predicted_Total <- predict(reg_model, data)
# Classification (Results: Pass/Fail)
data$Results <- as.factor(data$Results)
set.seed(123)
trainIndex <- createDataPartition(data$Results, p = 0.7, list = FALSE)
trainData <- data[trainIndex, ]
testData <- data[-trainIndex, ]
model <- train(Results ~ Hindi + English + Science + Maths + History + Geograpgy,
data = trainData, method = "glm", family = "binomial")
# Predict and evaluate
pred <- predict(model, newdata = testData)
confusionMatrix(pred, testData$Results)
results <- read.csv("~/FUNDAMENTALS OF DATA SCIENCE PROJECT FINAL/results.csv", stringsAsFactors=TRUE)
View(results)
library(ggplot2)
library(dplyr)
library(caret)
library(cluster)
library(factoextra)
library(e1071)
# Load dataset
data <- read.csv("C:/Users/padma/Downloads/results.csv")
load("~/FUNDAMENTALS OF DATA SCIENCE PROJECT FINAL/.RData")
View(index)
View(index)
View(index)
View(index)
View(index)
View(index)
View(index)
# Load libraries
library(ggplot2)
library(dplyr)
library(caret)
library(cluster)
library(factoextra)
library(e1071)
# Load dataset
data <- read.csv("C:/Users/padma/Downloads/results.csv")
library(ggplot2)
library(dplyr)
library(caret)
library(cluster)
library(factoextra)
library(e1071)
# Load dataset
data <- read.csv("C:\Users\padma\OneDrive\Documents\FUNDAMENTALS OF DATA SCIENCE PROJECT FINAL\results.csv")
library(ggplot2)
library(dplyr)
library(caret)
library(cluster)
library(factoextra)
library(e1071)
# Load dataset
data <- read.csv("C:\\Users\\padma\\OneDrive\\Documents\\FUNDAMENTALS OF DATA SCIENCE PROJECT FINAL\\results.csv")
# Descriptive statistics
summary(data)
sapply(data[,2:8], sd)  # standard deviation of scores
# Correlation matrix
cor_matrix <- cor(data[,2:7])
print(cor_matrix)
# K-Means Clustering
scores <- scale(data[,2:7])  # Standardize
kmeans_model <- kmeans(scores, centers = 3)
data$Cluster <- as.factor(kmeans_model$cluster)
# View first few cluster assignments
head(data[, c("Total", "Cluster")])
# Visualize clusters
fviz_cluster(kmeans_model, data = scores)
# Regression model (predicting Total)
reg_model <- lm(Total ~ Hindi + English + Science + Maths + History + Geograpgy, data = data)
summary(reg_model)
# Add predicted total to dataset
data$Predicted_Total <- predict(reg_model, data)
# Classification (Results: Pass/Fail)
data$Results <- as.factor(data$Results)
set.seed(123)
trainIndex <- createDataPartition(data$Results, p = 0.7, list = FALSE)
trainData <- data[trainIndex, ]
testData <- data[-trainIndex, ]
model <- train(Results ~ Hindi + English + Science + Maths + History + Geograpgy,
data = trainData, method = "glm", family = "binomial")
# Predict and evaluate
pred <- predict(model, newdata = testData)
confusionMatrix(pred, testData$Results)
library(ggplot2)
library(dplyr)
library(caret)
library(cluster)
library(factoextra)
library(e1071)
# Load dataset
data <- read.csv("C:/Users/padma/Downloads/results.csv")
library(ggplot2)
library(dplyr)
library(caret)
library(cluster)
library(factoextra)
library(e1071)
# Load dataset
data <- read.csv("C:\\Users\\padma\\Downloads\\results.csv")
library(ggplot2)
library(dplyr)
library(caret)
library(cluster)
library(factoextra)
library(e1071)
# Load dataset
data <- read.csv("C:\\Users\\padma\\OneDrive\\Documents\\FUNDAMENTALS OF DATA SCIENCE PROJECT FINAL\\results.csv")
# Descriptive statistics
summary(data)
sapply(data[,2:8], sd)  # standard deviation of scores
# Correlation matrix
cor_matrix <- cor(data[,2:7])
print(cor_matrix)
# K-Means Clustering
scores <- scale(data[,2:7])  # Standardize
kmeans_model <- kmeans(scores, centers = 3)
data$Cluster <- as.factor(kmeans_model$cluster)
# View first few cluster assignments
head(data[, c("Total", "Cluster")])
# Visualize clusters
fviz_cluster(kmeans_model, data = scores)
# Regression model (predicting Total)
reg_model <- lm(Total ~ Hindi + English + Science + Maths + History + Geograpgy, data = data)
summary(reg_model)
# Add predicted total to dataset
data$Predicted_Total <- predict(reg_model, data)
# Classification (Results: Pass/Fail)
data$Results <- as.factor(data$Results)
set.seed(123)
trainIndex <- createDataPartition(data$Results, p = 0.7, list = FALSE)
trainData <- data[trainIndex, ]
testData <- data[-trainIndex, ]
model <- train(Results ~ Hindi + English + Science + Maths + History + Geograpgy,
data = trainData, method = "glm", family = "binomial")
# Predict and evaluate
pred <- predict(model, newdata = testData)
confusionMatrix(pred, testData$Results)
library(shiny)
library(dplyr)
library(recommenderlab)
install.packages("tidytext")
install.packages("recommenderlab")
library(dplyr)
library(shiny)
library(recommenderlab)
# Load MovieLens data and filter for manageable size
data("MovieLense")
rating_data <- MovieLense[rowCounts(MovieLense) > 50, colCounts(MovieLense) > 100]
movie_titles <- colnames(rating_data)
# For UI, select a subset of movies for rating input (e.g., top 20)
movies_for_rating <- movie_titles[1:20]
ui <- fluidPage(
titlePanel("ðŸŽ¬ Rate Movies to Get Recommendations"),
sidebarLayout(
sidebarPanel(
h4("Rate some movies you have seen:"),
# Generate rating inputs dynamically
uiOutput("rating_inputs"),
actionButton("go", "Get Recommendations", class = "btn-primary"),
br(),
br(),
sliderInput("num_recs", "Number of Recommendations:", min = 1, max = 10, value = 5)
),
mainPanel(
h4("ðŸŽ¯ Recommended Movies:"),
tableOutput("recommendations")
)
)
)
server <- function(input, output, session) {
# Dynamically create rating input controls for movies
output$rating_inputs <- renderUI({
lapply(seq_along(movies_for_rating), function(i) {
movie <- movies_for_rating[i]
sliderInput(
inputId = paste0("rating_", i),
label = movie,
min = 0, max = 5, value = 0, step = 1,
ticks = FALSE
)
})
})
observeEvent(input$go, {
# Collect user ratings into a vector
user_ratings <- sapply(seq_along(movies_for_rating), function(i) {
rating <- input[[paste0("rating_", i)]]
if (is.null(rating) || rating == 0) NA else rating
})
# Create a user rating matrix row with NA for unrated
new_user <- matrix(NA, nrow = 1, ncol = ncol(rating_data))
colnames(new_user) <- colnames(rating_data)
# Fill in ratings for movies in the subset
new_user[1, movies_for_rating] <- user_ratings
# Convert to realRatingMatrix
new_user_rrm <- as(new_user, "realRatingMatrix")
# Build recommender model using User-Based Collaborative Filtering
rec_model <- Recommender(rating_data, method = "UBCF")
# Predict recommendations
preds <- predict(rec_model, new_user_rrm, n = input$num_recs)
rec_movies <- as(preds, "list")[[1]]
output$recommendations <- renderTable({
if (length(rec_movies) == 0) {
data.frame(Message = "No recommendations available. Please rate more movies.")
} else {
data.frame(Recommended_Movies = rec_movies)
}
})
})
}
shinyApp(ui = ui, server = server)
install.packages("shiny")
library(shiny)
